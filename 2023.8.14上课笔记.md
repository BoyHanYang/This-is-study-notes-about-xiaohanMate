# 递归与快速排序

## 递归

定义：递归是指一个方法或函数在执行过程中调用自身的过程。递归可以解决某种数据结构进行深度优先搜索或者遍历的问题。

递归函数通常包含两部分：基本情况和递归情况。基本情况是指问题可以直接解决的情况，通常是递归函数的终止条件，避免无限递归。递归情况是指问题需要进一步分解才能解决的情况，通常是指递归函数中调用自身的部分。

在递归函数中，每次递归都会将问题规模减小，知道达到基本情况，然后开始回溯并合并解决方案，直到最终解决问题。递归在某种情况下可以让程序更加简洁和优雅，但也可能会带来性能问题和堆栈溢出问题等。

样例代码：

```java
public static void main(String args){
	int num = 5;
	int pro = product(num);
	System.out.println(pro);
}
public static int product(int num){
	if(num==0||num==1){
		return 1;
	}
	int result = product(num-1);
	int pro = num * result;
	return pro;
}
```

现在可以感受到递归和循环有些相似，但又有些许不同。

### 递归和循环的区别

递归和循环在解决问题时都有各自的优点和缺点，下面是它们的一些特点：

递归的优点：

1. 代码简洁清晰：递归可以将复杂的问题分解为简单的子问题，使代码更易于理解和维护。
1. 解决复杂问题：递归适用于解决那些可以通过将问题分解为更小的子问题来求解的情况，尤其是在树、图等数据结构上的操作。
1. 可读性强：递归能够更直观地表达问题的本质和逻辑，使代码更易读。

递归的缺点：

1. 性能开销：递归可能导致重复计算和大量的函数调用，这可能会带来额外的性能开销。
1. 栈溢出：如果递归的层级太深，函数调用会占用大量的栈空间，可能导致栈溢出的错误。
1. 难以理解和调试：递归的运行过程比较隐晦，需要理解递归的原理才能正确使用和调试。

循环的优点：

1. 性能高效：循环通常比递归更高效，因为它避免了函数调用和重复计算的开销。
1. 控制结构灵活：循环的控制结构能够更灵活地控制循环的条件和迭代过程。
1. 内存占用低：循环通常不需要使用额外的栈空间，所以对内存的占用较低。

循环的缺点：

1. 代码冗余：循环可能需要编写更多的代码来实现相同的功能，尤其是在处理一些复杂的问题时。
1. 可读性较差：循环的代码结构相对复杂，可能需要更多的注释来解释循环的逻辑。
1. 容易出错：由于循环的控制条件和迭代过程较为复杂，容易出现循环条件错误或者死循环等问题。

在实际编程中，递归和循环都有各自的应用场景。选择使用哪种方式取决于问题的特性、性能需求和代码的可读性要求。有时候，递归和循环也可以结合使用，以充分发挥它们各自的优势。

## 快速排序

以下是快速排序的原理图：

![quickScore](https://s2.loli.net/2023/08/14/lexhWaUEIpHDJLQ.gif)

原理图解释：

找到一个基准值（base）；假想有两个双指针，一个在最最左端，一个在最右端，从最右端开始，向左移动，如果遇到了小于基准值的数字，则该指针暂停，左指针移动，左指针遇到大于基准值的数，暂停移动，并交换两指针的值，随后再次从右指针先开始移动，如此反复，直到左指针和右指针相遇，此时数组被分为了三部分，小于基准值的左半部分（混乱），基准值，大于基准值的右半部分（混乱）。此时需再次进行排序，从左半部分开始分解，排序完毕后再排序右半部分，按照上述步骤，如此往复，便可完成排序。

### 快速排序的优缺点

优点：

1. 高效性：在平均情况下，快速排序具有较高的性能。它的平均时间复杂度为O(n log n)，其中n是待排序元素的数量。相对于其他常见的排序算法，如冒泡排序和插入排序，它的性能更好。
2. 原地排序：快速排序是一种原地排序算法，它不需要额外的内存来存储临时数据。它通过修改原始数组中的元素来进行排序，减少了空间复杂度的需求。
3. 适应性：快速排序适用于各种不同类型的数据，包括整数、浮点数和字符串。它也适用于大型数据集和小型数据集。

缺点：

1. 不稳定性：快速排序是一种不稳定的排序算法。在排序过程中，相等元素的相对顺序可能会被改变。这意味着如果在排序中存在相同的元素，它们的相对顺序可能不会被保持。

2. 对于已排序或接近排序的数据表现较差：如果待排序的数据已经是有序的或接近有序的，快速排序的性能将下降。在这种情况下，快速排序的时间复杂度可能接近O(n^2)，比其他排序算法如归并排序的性能要差。

3. 递归调用的深度：快速排序的实现通常使用递归来分割和排序子数组。在某些情况下，递归调用的深度可能很大，当排序的数组非常大时，可能导致栈溢出的风险。

   

代码实现：

```java
public static void main(String[] args) {
        int[] arr = {6, 1, 2, 7, 9, 11, 4, 5, 10, 8};
        quickSort(arr, 0, arr.length-1);
        System.out.println(Arrays.toString(arr));
    }

    public static void quickSort(int[] arr, int start, int end) {
        if (start >= end) {
            return;
        }
        int left = start;
        int right = end;
        int base = arr[left];
        while (left < right) {
            while (left < right && arr[right] >= base) {
                right--;
            }
            while (left < right && arr[left] <= base) {
                left++;
            }
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
        }
        arr[start] = arr[left];
        arr[left] = base;
        quickSort(arr, start, left-1);
        quickSort(arr, left+1, end);
    }
```

